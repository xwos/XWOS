--[[--------
XWLUA模块：条件量

条件量是操作系统比较底层的同步机制，可以同时阻塞多个线程。当条件成立，条件量可以唤醒一个或所有正在等待的线程。

操作系统或语言库都提供了条件量的功能，例如：

　● POSIX的 `pthread_cond_t`
　● C++的 `std::condition_variable`
　● Java的 `java.util.concurrent.locks.Condition`
　● Python的 `threading.Condition`
　● Rust的 `std::sync::condvar`

线程需要在持有 **互斥锁** 的情况下去等待条件量，
条件量阻塞线程时会同步释放 **互斥锁** 。当条件成立，线程被唤醒时，条件量会自动上锁 **互斥锁** 。
等待条件量发生错误时，条件量也会自动上锁 **互斥锁** 后再返回。


XWLUA的条件量的功能类似，主要包括以下操作：

　● 线程 **A** 等待条件量的 **条件成立** 而阻塞；
　● 另一个线程 **B** 或中断上下文或其他上下文通过 **单播** 或 **广播** 使 **条件成立** ，并唤醒条件量上阻塞的线程 **A** 。
　● 线程 **A** 持有 **锁** 的情况下去等待条件量，会自动解锁；
　● 线程 **A** 持有 **锁** 的情况下去等待条件量，当等到 **条件成立** 时，会自动上锁；
　● 线程 **A** 持有 **锁** 的情况下去等待条件量，当发生错误返回时， **不会** 自动上锁；
　● 支持多种锁类型：
　　○ 互斥锁
　　○ 自旋锁
　　○ 顺序锁
　● 支持没有伴生锁的情况下操作。


@module xwos.sync.cond
]]

--[[--------
新建条件量



@treturn userdata 新的条件量对象的强指针 `condsp`

@usage
cond = xwos.cond.new() -- 创建条件量
]]
function new()
end
